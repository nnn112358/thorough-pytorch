# 3.5 モデルの初期化
重みの初期値は収束速度や最終精度に大きく影響します。全て 0 は対称性の問題で避けるべきで、適切な初期化を用います。PyTorch では `torch.nn.init` に代表的な初期化が用意されています。
本節のゴール：
- 代表的な初期化関数
- 初期化関数の使い方

## torch.nn.init の内容
公式ドキュメント[リンク](https://pytorch.org/docs/stable/nn.init.html) にある通り、主な関数は次の通りです：
1 . `torch.nn.init.uniform_`(tensor, a=0.0, b=1.0)
2 . `torch.nn.init.normal_`(tensor, mean=0.0, std=1.0)
3 . `torch.nn.init.constant_`(tensor, val)
4 . `torch.nn.init.ones_`(tensor)
5 . `torch.nn.init.zeros_`(tensor)
6 . `torch.nn.init.eye_`(tensor)
7 . `torch.nn.init.dirac_`(tensor, groups=1)
8 . `torch.nn.init.xavier_uniform_`(tensor, gain=1.0)
9 . `torch.nn.init.xavier_normal_`(tensor, gain=1.0)
10 . `torch.nn.init.kaiming_uniform_`(tensor, a=0, mode='fan__in', nonlinearity='leaky_relu')
11 . `torch.nn.init.kaiming_normal_`(tensor, a=0, mode='fan_in', nonlinearity='leaky_relu')
12 . `torch.nn.init.orthogonal_`(tensor, gain=1)
13 . `torch.nn.init.sparse_`(tensor, sparsity, std=0.01)
14 .  `torch.nn.init.calculate_gain`(nonlinearity, param=None)
ゲイン（`calculate_gain`）の目安：
|nonlinearity|gain|
| ---- | ---- |
|Linear/Identity|1|
|Conv{1,2,3}D|1|
|Sigmod|1|
|Tanh|5/3|
|ReLU|sqrt(2)|
|Leaky Relu|sqrt(2/1+neg_slop^2)|

`calculate_gain` を除き末尾がアンダースコアの関数は in-place でテンソルを書き換えます。

## 使い方
モジュールの種類に応じて `isinstance()` で分岐し、適切な初期化を適用します（3.4 の構築参照）。
```python
import torch
import torch.nn as nn

conv = nn.Conv2d(1,3,3)
linear = nn.Linear(10,1)

isinstance(conv,nn.Conv2d) # 判断conv是否是nn.Conv2d类型
isinstance(linear,nn.Conv2d) # 判断linear是否是nn.Conv2d类型
```
```python
True
False
```
層の種類に応じて方法を切り替えます。
```python
# 查看随机初始化的conv参数
conv.weight.data
# 查看linear的参数
linear.weight.data
```
```python
tensor([[[[ 0.1174,  0.1071,  0.2977],
          [-0.2634, -0.0583, -0.2465],
          [ 0.1726, -0.0452, -0.2354]]],
        [[[ 0.1382,  0.1853, -0.1515],
          [ 0.0561,  0.2798, -0.2488],
          [-0.1288,  0.0031,  0.2826]]],
        [[[ 0.2655,  0.2566, -0.1276],
          [ 0.1905, -0.1308,  0.2933],
          [ 0.0557, -0.1880,  0.0669]]]])

tensor([[-0.0089,  0.1186,  0.1213, -0.2569,  0.1381,  0.3125,  0.1118, -0.0063, -0.2330,  0.1956]])
```
```python
# 对conv进行kaiming初始化
torch.nn.init.kaiming_normal_(conv.weight.data)
conv.weight.data
# 对linear进行常数初始化
torch.nn.init.constant_(linear.weight.data,0.3)
linear.weight.data
```
```python
tensor([[[[ 0.3249, -0.0500,  0.6703],
          [-0.3561,  0.0946,  0.4380],
          [-0.9426,  0.9116,  0.4374]]],
        [[[ 0.6727,  0.9885,  0.1635],
          [ 0.7218, -1.2841, -0.2970],
          [-0.9128, -0.1134, -0.3846]]],
        [[[ 0.2018,  0.4668, -0.0937],
          [-0.2701, -0.3073,  0.6686],
          [-0.3269, -0.0094,  0.3246]]]])
tensor([[0.3000, 0.3000, 0.3000, 0.3000, 0.3000, 0.3000, 0.3000, 0.3000, 0.3000,0.3000]])
```
## 初期化関数のラップ
共通化のため `initialize_weights()` のような関数にまとめ、モデル生成後に適用します。
```python
def initialize_weights(model):
	for m in model.modules():
		# 判断是否属于Conv2d
		if isinstance(m, nn.Conv2d):
			torch.nn.init.zeros_(m.weight.data)
			# 判断是否有偏置
			if m.bias is not None:
				torch.nn.init.constant_(m.bias.data,0.3)
		elif isinstance(m, nn.Linear):
			torch.nn.init.normal_(m.weight.data, 0.1)
			if m.bias is not None:
				torch.nn.init.zeros_(m.bias.data)
		elif isinstance(m, nn.BatchNorm2d):
			m.weight.data.fill_(1) 		 
			m.bias.data.zeros_()	
```
この関数は各モジュールを走査し、型に応じて適切な初期化を適用します。簡単なデモ：
```python
# 模型的定义
class MLP(nn.Module):
  # 声明带有模型参数的层，这里声明了两个全连接层
  def __init__(self, **kwargs):
    # 调用MLP父类Block的构造函数来进行必要的初始化。这样在构造实例时还可以指定其他函数
    super(MLP, self).__init__(**kwargs)
    self.hidden = nn.Conv2d(1,1,3)
    self.act = nn.ReLU()
    self.output = nn.Linear(10,1)
    
   # 定义模型的前向计算，即如何根据输入x计算返回所需要的模型输出
  def forward(self, x):
    o = self.act(self.hidden(x))
    return self.output(o)

mlp = MLP()
print(mlp.hidden.weight.data)
print("-------初始化-------")

mlp.apply(initialize_weights)
# 或者initialize_weights(mlp)
print(mlp.hidden.weight.data)
```
```python
tensor([[[[ 0.3069, -0.1865,  0.0182],
          [ 0.2475,  0.3330,  0.1352],
          [-0.0247, -0.0786,  0.1278]]]])
"-------初始化-------"
tensor([[[[0., 0., 0.],
          [0., 0., 0.],
          [0., 0., 0.]]]])
```
注意：重みを 0 に揃えるのは避けてください（学習が進みません）。He/Kaiming や Xavier などの初期化、あるいは小さな乱数を用います。
