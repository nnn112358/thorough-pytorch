# 2.1 テンソル

この章では PyTorch の基礎としてテンソルを扱います。まずテンソルでデータをどう表現するかを掴み、続いて演算、最後に PyTorch の自動微分 `autograd` に触れます。深層学習では、RGB 画像を3次元テンソル、動画を4次元テンソルのように表現します。

本節のゴール：

- テンソルの概要
- PyTorch でのテンソル作成
- テンソルの操作
- ブロードキャストの仕組み

## 2.1.1 概要

テンソルはベクトルや行列の一般化です。0次はスカラー、1次はベクトル、2次は行列というように拡張していきます。
| 次元 | 例 | 
|---|---|
| 0次 | スカラー（数値） |
| 1次 | ベクトル |
| 2次 | 行列 |
| 3次 | 時系列・テキスト・単一のカラー画像（RGB） |

テンソルは現代の機械学習の基本的なデータコンテナです。多くは数値を格納します（文字列などを格納することも稀にあります）。

典型的なデータのテンソル次元：

- 3次元 = 時系列など
- 4次元 = 画像（バッチを含めると 4 次元）
- 5次元 = 動画

例：1 枚の画像は次の 3 つの軸で表せます。

```
(width, height, channel) = 3D
```

多数の画像をまとめて扱う場合はさらにバッチ軸を追加して 4 次元になります。

```
(batch_size, width, height, channel) = 4D
```

PyTorch では `torch.Tensor` がデータの保存と変換の中心です。NumPy の配列に似ていますが、GPU 計算や自動微分など深層学習に適した機能を備えています。

## 2.1.2 テンソルの作成
よく使うテンソル作成方法をいくつか挙げます。

1. ランダム初期化行列
`torch.rand()` で乱数から行列を作成できます。

```python
import torch
x = torch.rand(4, 3)
print(x)
```

2. 全ゼロ行列の作成
`torch.zeros()` で全て 0、`dtype` で型指定が可能。既存行列を 0 にする `zero_()` や同形状を作る `zeros_like()` もあります。

```python
import torch
x = torch.zeros(4, 3, dtype=torch.long)
print(x)
```

3. データから直接作成
`torch.tensor()` にリストや配列を渡して作成します。
```python
import torch
x = torch.tensor([5.5, 3]) 
print(x)
```
```python
tensor([5.5000, 3.0000])
```
4. 基于已经存在的 tensor，创建一个 tensor ：

```python
x = x.new_ones(4, 3, dtype=torch.double) 
# 创建一个新的全1矩阵tensor，返回的tensor默认具有相同的torch.dtype和torch.device
# 也可以像之前的写法 x = torch.ones(4, 3, dtype=torch.double)
print(x)
x = torch.randn_like(x, dtype=torch.float)
# 重置数据类型
print(x)
# 结果会有一样的size
# 获取它的维度信息
print(x.size())
print(x.shape)
```
```python
tensor([[1., 1., 1.],
        [1., 1., 1.],
        [1., 1., 1.],
        [1., 1., 1.]], dtype=torch.float64)
tensor([[ 2.7311, -0.0720,  0.2497],
        [-2.3141,  0.0666, -0.5934],
        [ 1.5253,  1.0336,  1.3859],
        [ 1.3806, -0.6965, -1.2255]])
torch.Size([4, 3])
torch.Size([4, 3])
```
返される `torch.Size` は実体としてはタプルで、タプル操作がそのまま使えます。インデックスでテンソルの縦横などの次元を取得できます。

5. よく使うテンソルのコンストラクタ：

| 関数 | 機能 |
|---|---|
| `Tensor(sizes)` | 基本コンストラクタ |
| `tensor(data)` | `np.array` に相当 |
| `ones(sizes)` | 全要素 1 |
| `zeros(sizes)` | 全要素 0 |
| `eye(sizes)` | 単位行列（対角 1, それ以外 0） |
| `arange(s,e,step)` | 範囲生成（s から e、刻み step） |
| `linspace(s,e,steps)` | 区間を等間隔に分割 |
| `rand/randn(sizes)` | 一様分布[0,1) / 正規分布N(0,1) |
| `normal(mean,std)` | 正規分布（平均 mean、標準偏差 std） |
| `randperm(m)` | 0..m-1 のランダム順列 |

## 2.1.3 テンソルの操作
代表的な操作をいくつか紹介します。
1. 加算：
```python
import torch
# 方法1
y = torch.rand(4, 3) 
print(x + y)

# 方法2
print(torch.add(x, y))

# 方法3 in-place（元の値を変更）
y.add_(x) 
print(y)
```
```python
tensor([[ 2.8977,  0.6581,  0.5856],
        [-1.3604,  0.1656, -0.0823],
        [ 2.1387,  1.7959,  1.5275],
        [ 2.2427, -0.3100, -0.4826]])
tensor([[ 2.8977,  0.6581,  0.5856],
        [-1.3604,  0.1656, -0.0823],
        [ 2.1387,  1.7959,  1.5275],
        [ 2.2427, -0.3100, -0.4826]])
tensor([[ 2.8977,  0.6581,  0.5856],
        [-1.3604,  0.1656, -0.0823],
        [ 2.1387,  1.7959,  1.5275],
        [ 2.2427, -0.3100, -0.4826]])

```
2. インデックス操作（NumPy と同様）

注意：インデックスで得られるビューは元のデータとメモリを共有します。一方を変更すると他方も変わります。独立させたい場合は `clone()` などを使います。

```python
import torch
x = torch.rand(4,3)
# 第2列を取得
print(x[:, 1]) 
```
```python
tensor([-0.0720,  0.0666,  1.0336, -0.6965])
```

```python
y = x[0,:]
y += 1
print(y)
print(x[0, :]) # 元のテンソルも変更されている
```
```python
tensor([3.7311, 0.9280, 1.2497])
tensor([3.7311, 0.9280, 1.2497])
```
3. 形状の変換
代表的には `torch.view()` と `torch.reshape()` があります。まずは `torch.view()`：

```python
x = torch.randn(4, 4)
y = x.view(16)
z = x.view(-1, 8) # -1是指这一维的维数由其他维度决定
print(x.size(), y.size(), z.size())
```
```python
torch.Size([4, 4]) torch.Size([16]) torch.Size([2, 8])
```
注：`torch.view()` が返すテンソルは元のテンソルとメモリを共有します（見え方だけを変える）。どちらかを変更するともう一方も変わります。

```python
x += 1
print(x)
print(y) # こちらも +1 される
```
```python
tensor([[ 1.3019,  0.3762,  1.2397,  1.3998],
        [ 0.6891,  1.3651,  1.1891, -0.6744],
        [ 0.3490,  1.8377,  1.6456,  0.8403],
        [-0.8259,  2.5454,  1.2474,  0.7884]])
tensor([ 1.3019,  0.3762,  1.2397,  1.3998,  0.6891,  1.3651,  1.1891, -0.6744,
         0.3490,  1.8377,  1.6456,  0.8403, -0.8259,  2.5454,  1.2474,  0.7884])
```
`torch.view()` の影響を避けたい場合は、まず `clone()` でコピーを作ってから `view()` を使うのが安全です（`reshape()` はコピーを保証しないため非推奨）。`clone()` は計算グラフにも記録され、勾配はコピー元にも伝播します。

4. 値の取得
要素が1つのテンソルは `.item()` で純粋な Python 値を取り出せます：

```python
import torch
x = torch.randn(1) 
print(type(x)) 
print(type(x.item()))
```
```python
<class 'torch.Tensor'>
<class 'float'>
```
PyTorch のテンソルは転置・インデックス・スライス・数値演算・線形代数・乱数など多数の操作をサポートします。詳細は[公式ドキュメント](https://pytorch.org/docs/stable/tensors.html)を参照してください。

## 2.1.4 ブロードキャスト

形状の異なるテンソル同士の要素演算では、必要に応じて自動的に要素が複製され、形状を揃えてから演算する「ブロードキャスト」が働きます。

```python
x = torch.arange(1, 3).view(1, 2)
print(x)
y = torch.arange(1, 4).view(3, 1)
print(y)
print(x + y)
```
```python
tensor([[1, 2]])
tensor([[1],
        [2],
        [3]])
tensor([[2, 3],
        [3, 4],
        [4, 5]])
```

x は 1×2、y は 3×1 なので、x の行方向、y の列方向にそれぞれ複製が行われ、最終的に 3×2 同士として要素加算できます。
