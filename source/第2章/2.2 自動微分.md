# 2.2 自動微分（autograd）

PyTorch の神経ネットワークの中核は `autograd` パッケージです。テンソル演算に対して自動で勾配を計算します。実行時定義（define-by-run）方式のため、コードの実行に応じて動的に計算グラフが構築・逆伝播されます。

本節のゴール：

- autograd による微分の仕組み
- 逆伝播と勾配の扱い

## Autograd 概要
`torch.Tensor` は `autograd` の中心クラスです。属性 `.requires_grad=True` を設定すると、そのテンソルに対する演算履歴が追跡されます。計算が終わったら `.backward()` を呼ぶことで勾配が自動計算され、勾配は `.grad` に蓄積されます。

注意：`y.backward()` のとき、`y` がスカラーなら引数は不要です。スカラーでない場合は `y` と同形のテンソルを引数に渡します。

履歴の追跡を止めたい場合は `.detach()` で計算グラフから切り離します。評価時には `with torch.no_grad():` でブロックを囲むと、`requires_grad=True` のパラメータを持つモデルでも勾配計算を行いません。

`autograd` では `Function` クラスも重要です。`Tensor` と `Function` は有向非巡回グラフ（DAG）を形成し計算履歴を表します。各テンソルの `.grad_fn` は、そのテンソルを生成した `Function` を参照します（ユーザーが直接作成したテンソルは `grad_fn=None`）。

```python
from __future__ import print_function
import torch
x = torch.randn(3,3,requires_grad=True)
print(x.grad_fn)
```
```python
None
```
導関数を計算するには、`Tensor` に対して `.backward()` を呼びます。`Tensor` がスカラーなら引数は不要ですが、それ以外の場合は形状の一致する `gradient` 引数を渡します。

创建一个张量并设置`requires_grad=True`用来追踪其计算历史

```python
x = torch.ones(2, 2, requires_grad=True)
print(x)
```
```python
tensor([[1., 1.],
        [1., 1.]], requires_grad=True)
```

对这个张量做一次运算：

```python
y = x**2
print(y)
```
```python
tensor([[1., 1.],
        [1., 1.]], grad_fn=<PowBackward0>)
```

`y`是计算的结果，所以它有`grad_fn`属性。

```python
print(y.grad_fn)
```
```python
<PowBackward0 object at 0x000001CB45988C70>
```

对 y 进行更多操作

```python
z = y * y * 3
out = z.mean()

print(z, out)
```
```python
tensor([[3., 3.],
        [3., 3.]], grad_fn=<MulBackward0>) tensor(3., grad_fn=<MeanBackward0>)
```
`.requires_grad_(...) `原地改变了现有张量的` requires_grad `标志。如果没有指定的话，默认输入的这个标志是` False`。

```python
a = torch.randn(2, 2) # 缺失情况下默认 requires_grad = False
a = ((a * 3) / (a - 1))
print(a.requires_grad)
a.requires_grad_(True)
print(a.requires_grad)
b = (a * a).sum()
print(b.grad_fn)
```
```python
False
True
<SumBackward0 object at 0x000001CB4A19FB50>
```


## 2.2.1 梯度

现在开始进行反向传播，因为` out` 是一个标量，因此` out.backward() `和` out.backward(torch.tensor(1.))` 等价。

```python
out.backward()
```

输出导数` d(out)/dx`

```python
print(x.grad)
```
```python
tensor([[3., 3.],
        [3., 3.]])
```
数学上，若有向量函数$\vec{y}=f(\vec{x})$，那么 $\vec{y}$ 关于 $\vec{x}$ 的梯度就是一个雅可比矩阵：
$
J=\left(\begin{array}{ccc}\frac{\partial y_{1}}{\partial x_{1}} & \cdots & \frac{\partial y_{1}}{\partial x_{n}} \\ \vdots & \ddots & \vdots \\ \frac{\partial y_{m}}{\partial x_{1}} & \cdots & \frac{\partial y_{m}}{\partial x_{n}}\end{array}\right)
$
而 `torch.autograd` 这个包就是用来计算一些雅可比矩阵的乘积的。例如，如果 $v$ 是一个标量函数 $l = g(\vec{y})$ 的梯度：
$
v=\left(\begin{array}{lll}\frac{\partial l}{\partial y_{1}} & \cdots & \frac{\partial l}{\partial y_{m}}\end{array}\right)
$
由链式法则，我们可以得到：
$
v J=\left(\begin{array}{lll}\frac{\partial l}{\partial y_{1}} & \cdots & \frac{\partial l}{\partial y_{m}}\end{array}\right)\left(\begin{array}{ccc}\frac{\partial y_{1}}{\partial x_{1}} & \cdots & \frac{\partial y_{1}}{\partial x_{n}} \\ \vdots & \ddots & \vdots \\ \frac{\partial y_{m}}{\partial x_{1}} & \cdots & \frac{\partial y_{m}}{\partial x_{n}}\end{array}\right)=\left(\begin{array}{lll}\frac{\partial l}{\partial x_{1}} & \cdots & \frac{\partial l}{\partial x_{n}}\end{array}\right)
$


注意：勾配 `grad` は累積されます。すなわち `backward()` を複数回呼ぶと前回までの勾配に加算されます。通常は各ステップの前にゼロクリアします。

```python
# 再来反向传播⼀一次，注意grad是累加的
out2 = x.sum()
out2.backward()
print(x.grad)

out3 = x.sum()
x.grad.data.zero_()
out3.backward()
print(x.grad)
```
```python
tensor([[4., 4.],
        [4., 4.]])
tensor([[1., 1.],
        [1., 1.]])
```
次に、ヤコビアンとベクトルの積（Jv）の例です：

```python
x = torch.randn(3, requires_grad=True)
print(x)

y = x * 2
i = 0
while y.data.norm() < 1000:
    y = y * 2
    i = i + 1
print(y)
print(i)
```
```python
tensor([-0.9332,  1.9616,  0.1739], requires_grad=True)
tensor([-477.7843, 1004.3264,   89.0424], grad_fn=<MulBackward0>)
8
```

この場合 `y` はスカラーではありません。`torch.autograd` はヤコビアン全体は直接計算しませんが、ヤコビアンとベクトルの積が欲しい場合は、そのベクトルを `backward()` に渡します。

```python
v = torch.tensor([0.1, 1.0, 0.0001], dtype=torch.float)
y.backward(v)

print(x.grad)
```
```python
tensor([5.1200e+01, 5.1200e+02, 5.1200e-02])
```

`with torch.no_grad():` でコードを囲むと、`requires_grad=True` のテンソルであっても履歴追跡を抑制できます。

```python
print(x.requires_grad)
print((x ** 2).requires_grad)

with torch.no_grad():
    print((x ** 2).requires_grad)
```
```python
True
True
False
```

計算グラフに記録させず（勾配計算へ影響させず）に値だけ変更したい場合、`tensor.data` を操作します（高度な使い方なので注意）。

```python
x = torch.ones(1,requires_grad=True)

print(x.data) # 还是一个tensor
print(x.data.requires_grad) # 但是已经是独立于计算图之外

y = 2 * x
x.data *= 100 # 只改变了值，不会记录在计算图，所以不会影响梯度传播

y.backward()
print(x) # 更改data的值也会影响tensor的值 
print(x.grad)
```
```python
tensor([1.])
False
tensor([100.], requires_grad=True)
tensor([2.])
```










